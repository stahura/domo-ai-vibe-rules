# ⚠️ DEPRECATED - This file is deprecated

**This `.cursorrules` file is deprecated.** Cursor now uses `.cursor/rules/*.mdc` files instead.

**Please use the new format:** All rules have been migrated to `.cursor/rules/` directory with individual `.mdc` files:
- `01-overview.mdc` - Introduction, SSR check, API overview
- `02-ryuu-js.mdc` - domo.js SDK utilities
- `03-query.mdc` - @domoinc/query
- `04-toolkit.mdc` - @domoinc/toolkit service clients
- `05-da-cli.mdc` - DA CLI and conversion guide
- `06-manifest.mdc` - manifest.json
- `07-build-deploy.mdc` - Build and deployment
- `08-routing-config.mdc` - Routing and Vite config
- `09-gotchas.mdc` - Common gotchas and troubleshooting

This file is kept for backward compatibility but will not be updated.

---

# Domo App Platform Custom App Development

You are helping build a Domo App Platform Custom App. This is a client-side web application that runs inside the Domo platform and uses Domo's App Framework APIs.

**Important:** Do NOT confuse the App Platform/Framework APIs with Domo's Public API or Product API - they are different. The App Platform APIs are specifically for custom apps running inside Domo.

---

## ⚠️ Server-Side Rendering Check

**Domo custom apps are client-side only.** There is no server to render pages — Domo serves static files.

When you first look at a project (especially one from Lovable, v0, or similar tools), immediately check for server-side rendering (SSR). If SSR is present, **stop and warn the user** before proceeding.

### Signs of SSR (incompatible with Domo):
- Next.js with `getServerSideProps`, `getStaticProps`, or App Router server components
- Remix with loaders or actions
- SvelteKit with `+page.server.js` or `+server.js` files
- Nuxt.js with server routes
- `pages/api/` or `app/api/` directories (API routes)
- Server-side `process.env` usage for secrets
- Database connections in page components
- `"use server"` directives

### If SSR is detected:
1. **Immediately alert the user** that the project uses server-side rendering
2. Explain that Domo custom apps cannot use SSR — they must be pure client-side apps
3. Recommend refactoring to a client-side only approach (React + Vite is recommended)
4. If they need server-side logic, suggest using Domo Code Engine instead

---

## Domo App Framework APIs

The following APIs are available to custom apps via the `domo.js` library (automatically included when running in Domo):

| API | Purpose |
|-----|---------|
| **Data API** | Query datasets mapped in manifest (`/data/v1/`, `/sql/v1/`) |
| **AppDB** | Document-style collections for app storage (`/domo/datastores/v1/collections/`) |
| **AI Service Layer** | Text generation, image-to-text (`/domo/ai/v1/`) |
| **Code Engine** | Server-side functions for secure operations (`/domo/codeengine/v2/packages/`) |
| **Workflows** | Trigger automation workflows (`/domo/workflow/v1/models/`) |
| **Files** | File storage and retrieval |
| **Filesets** | Grouped file management |
| **Groups** | Domo group information |
| **User** | Current user context |
| **Task Center** | Task management |

See the individual rule files in this repo for detailed usage of each API.

---

## Installing domo.js (ryuu.js)

**React / npm projects:**
```bash
npm install ryuu.js
```
```javascript
import domo from 'ryuu.js';
```

**Vanilla JavaScript (CDN):**
```html
<script src="https://app.unpkg.com/ryuu.js@5.1.2"></script>
```

---

## domo.js Utilities

Beyond the APIs, domo.js provides useful utilities for interacting with the Domo environment:

### Environment Info

Access environment information. **WARNING: Can be spoofed! Do not use for security.**

```javascript
console.log(domo.env.userId);    // User ID (spoofable!)
console.log(domo.env.customer);  // Customer/instance name
console.log(domo.env.pageId);    // Current page ID
console.log(domo.env.locale);    // Locale (e.g., 'en-US')
console.log(domo.env.platform);  // 'desktop' or 'mobile'
```

**For secure user verification:**
```javascript
// ✅ SECURE - Server-verified identity
const verifiedEnv = await domo.get('/domo/environment/v1/');
const { userId, userName, userEmail } = verifiedEnv;

// Or use IdentityClient from toolkit
import { IdentityClient } from '@domoinc/toolkit';
const response = await IdentityClient.get();
const user = response.body; // { id, displayName, emailAddress, role }
```

### Event Listeners
```javascript
// React to dataset updates on the page
domo.onDataUpdated((alias) => {
  console.log(`Dataset ${alias} was updated`);
  // Refresh your data or do nothing to prevent auto-reload
});

// React to page filter changes
domo.onFiltersUpdated((filters) => {
  console.log('Filters changed:', filters);
  // Apply filters to your visualization
});

// React to Domo variable changes
domo.onVariablesUpdated((variables) => {
  console.log('Variables updated:', variables);
});
```

### Navigation
**Important:** Standard anchor tags with `href` do NOT work properly in Domo apps. You must use `domo.navigate()`:

```javascript
// Navigate within Domo
domo.navigate('/page/123456789');

// Open in new tab
domo.navigate('/page/123456789', true);

// External URLs also work
domo.navigate('https://example.com', true);
```

### Fetch Multiple Datasets
```javascript
// Load multiple datasets in parallel
const [sales, customers, products] = await domo.getAll([
  '/data/v1/sales',
  '/data/v1/customers',
  '/data/v1/products'
]);
```

### Update Page Filters Programmatically
```javascript
domo.requestFiltersUpdate(
  [
    {
      column: 'category',
      operator: 'IN',
      values: ['Electronics', 'Clothing'],
      dataType: 'STRING'
    }
  ],
  true, // apply to page
  () => console.log('Filter update acknowledged'),
  (response) => console.log('Filter update completed:', response)
);
```

---

## @domoinc/query - Data Query Builder

**CRITICAL:** Use the Query API (via @domoinc/query) for all dataset queries in Domo apps. This is essential because:

1. **Page Filter Integration** - The Query API automatically respects page-level filters when your app is embedded in a Domo dashboard. This is key for apps that need to respond to dashboard filter changes.

2. **Performance** - The Query API allows you to query only the data you need at the aggregation level required, rather than fetching entire datasets. This is critical for performance, especially with large datasets.

3. **Server-Side Processing** - Aggregations and filtering happen on Domo's servers, reducing data transfer and client-side processing.

The Query library provides a chainable API for building complex data queries. It constructs URLs that work with `domo.get()` and the `/data/v1/` endpoint.

**npm/yarn:**
```bash
yarn add @domoinc/query
```

```typescript
import Query from '@domoinc/query';
```

**CDN (Vanilla JavaScript):**
```html
<script src="https://cdn.jsdelivr.net/npm/@domoinc/query@3.0.0/dist/main.min.js"></script>
```

```javascript
// Query is available globally after CDN script loads
const data = await new Query()
  .select(['region', 'sales'])
  .fetch('sales-dataset');
```

### Basic Usage

```typescript
// Simple query
const data = await new Query()
  .select(['region', 'sales', 'date'])
  .fetch('sales-dataset');

// With filtering
const filtered = await new Query()
  .select(['region', 'product', 'sales'])
  .where('sales').greaterThan(1000)
  .where('region').in(['North', 'South'])
  .fetch('sales-dataset');

// With grouping and aggregation
const summary = await new Query()
  .select(['region', 'sales', 'quantity'])
  .groupBy('region')
  .groupBy({ sales: 'sum', quantity: 'avg' })
  .orderBy('sales', 'descending')
  .limit(10)
  .fetch('sales-dataset');
```

### Select

```typescript
// Select specific columns
new Query().select(['col1', 'col2', 'col3'])

// Select all (omit select)
new Query().fetch('dataset')
```

### Where Filters

All filter methods return the Query for chaining.

```typescript
// Comparison filters
.where('amount').lessThan(100)           // .lt(100)
.where('amount').lessThanOrEqual(100)    // .lte(100)
.where('amount').greaterThan(100)        // .gt(100)
.where('amount').greaterThanOrEqual(100) // .gte(100)
.where('amount').equals(100)
.where('amount').notEquals(100)
.where('amount').between(100, 500)

// String filters
.where('name').contains('test')
.where('name').notContains('test')

// List filters
.where('category').in(['A', 'B', 'C'])
.where('status').notIn(['deleted', 'archived'])

// Multiple conditions (AND)
.where('amount').greaterThan(100)
.where('status').equals('active')
.where('region').in(['North', 'South'])
```

### Group By

```typescript
// Group by single column
.groupBy('region')

// Group by multiple columns
.groupBy('region')
.groupBy('product')

// Group by column with aggregations (second parameter)
.groupBy('region', { 
  sales: 'sum',
  quantity: 'avg',
  price: 'max',
  orders: 'count',
  skus: 'unique'
})

// Multiple groupBy calls
.groupBy('region')
.groupBy('product', { sales: 'sum', orders: 'count' })
```

**Aggregation Functions:**
- `'count'` - Count rows
- `'sum'` - Sum values
- `'avg'` - Average values
- `'min'` - Minimum value
- `'max'` - Maximum value
- `'unique'` - Count distinct values

#### CRITICAL - Aggregation Key Syntax

**Aggregation keys MUST be the actual field names from your dataset, NOT custom aliases.**

The key in the aggregation object determines the output property name. If you use an alias that doesn't match a field, you'll get `[object Object]` errors.

```typescript
// ✅ CORRECT - Keys match actual field names
// If your dataset has fields: 'Sales_Amount', 'Order_Qty'
.groupBy('region', { 
  Sales_Amount: 'sum',   // Key matches dataset field
  Order_Qty: 'count'     // Key matches dataset field
})

// Results: [{ region: 'North', Sales_Amount: 50000, Order_Qty: 150 }]

// ❌ WRONG - Custom aliases as keys cause [object Object] errors
.groupBy('region', { 
  totalSales: 'sum',     // 'totalSales' is not a field name!
  orderCount: 'count'    // 'orderCount' is not a field name!
})

// ✅ If you need custom names, rename AFTER fetching:
const data = await new Query()
  .groupBy('region', { Sales_Amount: 'sum' })
  .fetch('sales');

const renamed = data.map(row => ({
  region: row.region,
  totalSales: row.Sales_Amount  // Rename here
}));
```

### Order By

```typescript
.orderBy('sales', 'descending')  // or 'desc'
.orderBy('date', 'ascending')    // or 'asc'

// Multiple sort columns
.orderBy('region', 'ascending')
.orderBy('sales', 'descending')
```

### Limit and Offset

```typescript
.limit(100)    // Max rows
.offset(50)    // Skip rows (for pagination)

// Pagination example
const page = 2;
const pageSize = 25;
new Query()
  .limit(pageSize)
  .offset((page - 1) * pageSize)
  .fetch('dataset');
```

### Date Operations

#### dateGrain - Group by Date Period

```typescript
// Group by month
.dateGrain('order_date', 'month')

// Group by month with aggregations
// NOTE: Aggregation keys must be actual field names!
.dateGrain('order_date', 'month', { Revenue: 'sum', Order_Count: 'count' })

// Available grains: 'day', 'week', 'month', 'quarter', 'year'
.dateGrain('date', 'day')
.dateGrain('date', 'week')
.dateGrain('date', 'month')
.dateGrain('date', 'quarter')
.dateGrain('date', 'year')
```

**CRITICAL:** The third parameter (aggregations) follows the same rules as `groupBy` - keys must match actual dataset field names:

```typescript
// ✅ CORRECT - field names as keys
.dateGrain('order_date', 'month', { Sales_Amount: 'sum' })

// ❌ WRONG - custom aliases cause errors
.dateGrain('order_date', 'month', { totalSales: 'sum' })
```

#### periodToDate - YTD, MTD, QTD, etc.

```typescript
// Year to date
.periodToDate('date', 'year')

// Month to date
.periodToDate('date', 'month')

// Quarter to date
.periodToDate('date', 'quarter')

// Full example
const ytdSales = await new Query()
  .select(['date', 'sales'])
  .periodToDate('date', 'year')
  .groupBy({ sales: 'sum' })
  .fetch('sales');
```

#### previousPeriod - Last Period Comparison

```typescript
// Last year
.previousPeriod('date', 'year')

// Last month
.previousPeriod('date', 'month')

// Last quarter
.previousPeriod('date', 'quarter')
```

#### rollingPeriod - Rolling Windows

```typescript
// Last 30 days
.rollingPeriod('date', 'days', 30)

// Last 12 weeks
.rollingPeriod('date', 'weeks', 12)

// Last 6 months
.rollingPeriod('date', 'months', 6)

// Last 4 quarters
.rollingPeriod('date', 'quarters', 4)

// Last 3 years
.rollingPeriod('date', 'years', 3)
```

### Additional Options

```typescript
// Use fiscal calendar
.useFiscalCalendar(true)

// Enable beast modes (calculated fields)
.useBeastModes()

// Aggregate without grouping
.aggregate({ total: 'sum', average: 'avg' })
```

### Complete Examples

```typescript
// Sales dashboard query
const salesByRegion = await new Query()
  .select(['region', 'product_category', 'sales', 'quantity', 'date'])
  .where('sales').greaterThan(0)
  .where('date').greaterThanOrEqual('2024-01-01')
  .dateGrain('date', 'month')
  .groupBy('region')
  .groupBy('product_category')
  .groupBy({ sales: 'sum', quantity: 'sum', orders: 'count' })
  .orderBy('sales', 'descending')
  .limit(100)
  .fetch('sales-dataset');

// YoY comparison
const thisYear = await new Query()
  .select(['month', 'revenue'])
  .periodToDate('date', 'year')
  .dateGrain('date', 'month', { revenue: 'sum' })
  .fetch('revenue');

const lastYear = await new Query()
  .select(['month', 'revenue'])
  .previousPeriod('date', 'year')
  .dateGrain('date', 'month', { revenue: 'sum' })
  .fetch('revenue');

// Trend analysis - last 90 days
const trend = await new Query()
  .select(['date', 'sales', 'orders'])
  .rollingPeriod('date', 'days', 90)
  .dateGrain('date', 'day', { sales: 'sum', orders: 'count' })
  .orderBy('date', 'ascending')
  .fetch('sales');
```

---

## @domoinc/toolkit - Service Clients

The toolkit provides typed client classes for Domo services.

```bash
yarn add @domoinc/toolkit
```

```typescript
import {
  AppDBClient,
  AIClient,
  IdentityClient,
  SqlClient,
  UserClient,
  GroupClient,
  FileClient,
  CodeEngineClient,
  WorkflowClient,
  DomoClient
} from '@domoinc/toolkit';
```

### Response Wrapper

All toolkit methods return a response wrapper:

```typescript
interface ToolkitResponse<T> {
  body: T;        // The actual data
  status: number; // HTTP status code
  headers?: Record<string, string>;
}

// Usage
const response = await IdentityClient.get();
const user = response.body;  // Access the data
const status = response.status;
```

### AppDBClient - NoSQL Document Store

**PREFERRED for CRUD apps and long text storage.** Collections can sync to Domo datasets.

#### DocumentsClient

```typescript
// Define your document type
interface Task {
  title: string;
  description: string;
  status: 'active' | 'completed';
  priority: 'Low' | 'High' | 'Urgent';
  dueDate?: string;
}

// Create client for a collection
const tasksClient = new AppDBClient.DocumentsClient<Task>('TasksCollection');
```

**Create Documents:**
```typescript
// Create single document
const response = await tasksClient.create({
  title: 'New Task',
  description: 'Task description',
  status: 'active',
  priority: 'High'
});
const newTask = response.body;
// Returns: { id: 'uuid', content: {...}, owner: 'userId', createdOn: '...', updatedOn: '...' }

// Create multiple documents
const response = await tasksClient.create([
  { title: 'Task 1', status: 'active', priority: 'Low' },
  { title: 'Task 2', status: 'active', priority: 'High' }
]);
```

**Read/Query Documents:**
```typescript
// Get all documents
const response = await tasksClient.get();
const tasks = response.body;

// Filter with MongoDB-style queries
const activeTasks = await tasksClient.get({
  status: { $eq: 'active' }
});

const highPriority = await tasksClient.get({
  priority: { $in: ['High', 'Urgent'] },
  status: { $ne: 'completed' }
});

// Complex queries
const filtered = await tasksClient.get({
  $and: [
    { status: { $eq: 'active' } },
    { priority: { $in: ['High', 'Urgent'] } }
  ]
});

const either = await tasksClient.get({
  $or: [
    { priority: { $eq: 'Urgent' } },
    { status: { $eq: 'completed' } }
  ]
});

// With pagination and sorting
const paginated = await tasksClient.get(
  { status: { $eq: 'active' } },
  {
    limit: 10,
    offset: 0,
    orderby: ['priority', 'dueDate']
  }
);

// Aggregations
const statusCounts = await tasksClient.get(
  {},
  {
    groupby: ['status'],
    count: 'id'
  }
);

const priorityStats = await tasksClient.get(
  {},
  {
    groupby: ['priority'],
    count: 'id',
    avg: ['estimatedHours']
  }
);
```

**MongoDB Query Operators:**
- `$eq` - Equals
- `$ne` - Not equals
- `$gt` - Greater than
- `$gte` - Greater than or equal
- `$lt` - Less than
- `$lte` - Less than or equal
- `$in` - In array
- `$nin` - Not in array
- `$regex` - Regular expression match
- `$and` - Logical AND
- `$or` - Logical OR

**Update Documents:**
```typescript
// Full update (replace content)
const response = await tasksClient.update({
  id: 'document-uuid',
  content: {
    title: 'Updated Title',
    description: 'Updated description',
    status: 'completed',
    priority: 'Low'
  }
});

// Bulk update
const bulkResponse = await tasksClient.update([
  { id: 'uuid-1', content: { title: 'Updated 1', status: 'active', priority: 'Low' } },
  { id: 'uuid-2', content: { title: 'Updated 2', status: 'active', priority: 'High' } }
]);
// Returns: { body: { updated: 2, inserted: 0 } }

// Partial update with MongoDB operators
const count = await tasksClient.partialUpdate(
  { status: { $eq: 'active' } },  // Filter
  { $set: { status: 'archived' } }  // Operation
);
// Returns number of documents updated

// Partial update operators
await tasksClient.partialUpdate(
  { priority: { $eq: 'Low' } },
  {
    $set: { priority: 'Medium', updatedAt: new Date().toISOString() },
    $unset: { tempField: 1 },
    $inc: { viewCount: 1 }
  }
);
```

**MongoDB Update Operators:**
- `$set` - Set field values
- `$unset` - Remove fields
- `$inc` - Increment numeric fields
- `$push` - Add to array fields

**Delete Documents:**
```typescript
// Delete single document
await tasksClient.delete('document-uuid');

// Bulk delete
const response = await tasksClient.delete(['uuid-1', 'uuid-2', 'uuid-3']);
// Returns: { body: { deleted: 3 } }
```

#### CollectionsClient

```typescript
const collectionsClient = new AppDBClient.CollectionsClient();

// List all collections
const collections = await collectionsClient.list();

// Create collection
await collectionsClient.create({
  name: 'NewCollection',
  schema: {
    columns: [
      { name: 'field1', type: 'STRING' },
      { name: 'field2', type: 'LONG' }
    ]
  }
});

// Delete collection
await collectionsClient.delete('CollectionName');

// Export all collections
const exportData = await collectionsClient.export();
```

### IdentityClient - Current User (SECURE)

**Use this instead of Domo.env for security-sensitive operations.**

```typescript
// Get current authenticated user
const response = await IdentityClient.get();
const user = response.body;
// {
//   id: 12345,
//   displayName: 'John Doe',
//   userName: 'jdoe',
//   emailAddress: 'jdoe@company.com',
//   avatarKey: 'abc123',
//   role: 'Admin',
//   groups: [{ id: 1, name: 'Everyone' }, ...]
// }

// With options
const response = await IdentityClient.get(
  5000,  // timeout in ms
  false  // includeGroups - set false for faster response
);
```

### SqlClient - Direct SQL Queries

**Note:** SQL endpoint does NOT respect page filters. Use Query endpoint for dashboard-embedded apps.

```typescript
const sqlClient = new SqlClient();

// Execute SQL query
const response = await sqlClient.get(
  'sales-dataset-alias',
  'SELECT region, SUM(amount) as total FROM sales-dataset-alias GROUP BY region ORDER BY total DESC'
);
const result = response.body;
// {
//   columns: ['region', 'total'],
//   rows: [{ region: 'North', total: 50000 }, ...],
//   numRows: 4,
//   numColumns: 2
// }

// Complex query
const response = await sqlClient.get(
  'sales',
  `SELECT 
    DATE_TRUNC('month', order_date) as month,
    product_category,
    SUM(revenue) as revenue,
    COUNT(*) as orders
   FROM sales
   WHERE order_date >= '2024-01-01'
   GROUP BY 1, 2
   ORDER BY 1, 3 DESC`
);

// Parse page filters into SQL (static method)
const predicates = SqlClient.parsePageFilters(['dataset1', 'dataset2']);
// Returns: { 'dataset1': [{ where: '"column" = \'value\'', having: '' }], ... }

// Get concatenated clauses
const clauses = SqlClient.parsePageFilters(['dataset1'], true);
// Returns: { 'dataset1': { whereClause: 'WHERE ...', havingClause: '' } }
```

### UserClient - User API

```typescript
// Get paginated list of users
const response = await UserClient.get(
  50,    // limit
  0,     // offset
  true   // includeDetails
);
const users = response.body;

// Get specific user
const response = await UserClient.getUser(
  12345,  // user ID
  true    // includeDetails
);
const user = response.body;

// Get user avatar
const avatarBlob = await UserClient.getAvatar(
  'avatar-key-from-user',
  'medium'  // 'small' | 'medium' | 'large'
);
```

### GroupClient - Groups API

```typescript
// Get all groups
const response = await GroupClient.get(50, 0);  // limit, offset
const groups = response.body;

// Get specific group
const response = await GroupClient.getGroup(456);
const group = response.body;

// Get group members
const response = await GroupClient.getMembers(456);
const members = response.body;  // Array of User objects
```

### FileClient - File Storage

```typescript
const fileClient = new FileClient();

// Upload file
const response = await fileClient.upload(
  fileObject,        // File object
  'report.pdf',      // Display name
  'Monthly report',  // Description (optional)
  true,              // isPublic (optional, default true)
  10000              // timeout (optional)
);
const fileId = response.body.id;

// Upload new revision
const response = await fileClient.uploadRevision(
  newFileObject,
  existingFileId
);

// Download file
const blob = await fileClient.download(
  fileId,
  'filename.pdf',
  revisionId  // optional, latest if omitted
);

// List files with details
const response = await fileClient.detailsList(
  [123, 456],  // File IDs (empty for all)
  ['metadata', 'permissions', 'revisions']  // Expand options
);

// Get/update permissions
const perms = await fileClient.getPermissions(fileId);
await fileClient.updatePermissions(fileId, JSON.stringify({
  public: false,
  users: [123, 456],
  groups: [789]
}));

// Delete file revision
await fileClient.delete(fileId, revisionId);
```

### AIClient - AI Services

All methods are static and use **snake_case** naming.

**Response Structure:**
**IMPORTANT:** AIClient uses `data` instead of `body` for the response payload! The toolkit wraps responses in `{ data, status, statusCode }`. The API response includes both a top-level `output` field and a `choices` array. Prefer the top-level `output` field when available.

```typescript
// Text generation
const response = await AIClient.generate_text(
  'Explain this sales trend in simple terms',
  { template: 'You are a business analyst. ${input}' },  // promptTemplate
  { tone: 'professional' },  // parameters for template
  'model-id',  // optional model override
  { temperature: 0.7 }  // model configuration
);

// Response structure: { data: { output: string, choices: [{ output: string }], ... }, status: "OK", statusCode: 200 }
// NOTE: AIClient uses 'data' not 'body'!
// Prefer top-level output field (more reliable)
const responseBody = response.data || response.body || response;
const text = responseBody.output || responseBody.choices?.[0]?.output;

// Text to SQL
const response = await AIClient.text_to_sql(
  'Show me total sales by region for Q4',
  [{
    dataSourceName: 'Sales',
    description: 'Sales transactions table',
    columns: [
      { name: 'region', type: 'string' },
      { name: 'amount', type: 'number' },
      { name: 'order_date', type: 'date' }
    ]
  }]
);
const responseBody = response.data || response.body || response;
const sql = responseBody.output || responseBody.choices?.[0]?.output;

// Text to Beast Mode (calculated field)
const response = await AIClient.text_to_beastmode(
  'Calculate year over year growth percentage',
  {
    dataSourceName: 'Revenue',
    columns: [
      { name: 'revenue', type: 'number' },
      { name: 'date', type: 'date' }
    ]
  }
);
const responseBody = response.data || response.body || response;
const beastMode = responseBody.output || responseBody.choices?.[0]?.output;

// Text summarization
const response = await AIClient.summarize(
  longTextContent,
  undefined,  // promptTemplate
  undefined,  // parameters
  undefined,  // model
  undefined,  // modelConfiguration
  undefined,  // system prompt
  [],         // chatContext
  { separatorType: 'paragraph' },  // chunkingConfiguration
  'bullets',  // outputStyle: 'paragraph' | 'bullets'
  100         // outputWordLength
);
const responseBody = response.data || response.body || response;
const summary = responseBody.output || responseBody.choices?.[0]?.output;
```

### CodeEngineClient - Serverless Functions

Requires `packageMapping` in manifest.json.

```typescript
// Execute function
const response = await CodeEngineClient.execute(
  'calculateTax',  // Function alias from manifest
  { amount: 1000, state: 'CA' }
);
const result = response.body.output;
```

### WorkflowClient - Domo Workflows

```typescript
// List available workflow models
const response = await WorkflowClient.getModels();
const models = response.body;

// Get model details
const response = await WorkflowClient.getModel('model-uuid');
const model = response.body;

// Start workflow instance
const response = await WorkflowClient.start(
  'model-uuid',
  { inputVar: 'value', anotherVar: 123 }
);
const instance = response.body;
// { id: 'instance-uuid', modelId: '...', status: 'RUNNING', ... }

// Check instance status
const response = await WorkflowClient.getInstance('instance-uuid');
const status = response.body;
// { id: '...', status: 'COMPLETED' | 'RUNNING' | 'FAILED', ... }
```

### DomoClient - Alternative to ryuu.js

```typescript
// Same as Domo.get/post/put/delete but from toolkit
const data = await DomoClient.get('/data/v1/sales');
await DomoClient.post('/api/items', { name: 'test' });
await DomoClient.put('/api/items/123', { name: 'updated' });
await DomoClient.delete('/api/items/123');
```

---

## manifest.json

The `manifest.json` file is critical - it declares all external resources your app needs. Domo uses this to:
1. Know which datasets, collections, workflows, and code engine functions to connect
2. Map aliases (used in your code) to actual Domo resource IDs (configured at publish time)

### Basic structure
```json
{
  "name": "My App Name",
  "version": "1.0.0",
  "id": "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx",
  "fullpage": true,
  "size": {
    "width": 4,
    "height": 3
  },
  "datasetsMapping": [],
  "collections": [],
  "workflowMapping": [],
  "packageMapping": []
}
```

### Key properties
- `name` / `version` - App metadata
- `id` - **Generated on first publish** (see deployment section)
- `fullpage` - Set `true` for full-page apps
- `size` - Card dimensions (width/height in grid units)
- `datasetsMapping` - Datasets the app can query
- `collections` - AppDB collections for storage
- `workflowMapping` - Workflows the app can trigger
- `packageMapping` - Code Engine functions the app can call

### Required files
- `manifest.json` - App configuration (required)
- `thumbnail.png` - App thumbnail image (required, must be alongside manifest.json)

---

## Build & Deploy Workflow

### Prerequisites
- Node.js installed
- Domo CLI installed (`npm install -g @domoinc/ryuu`)

### Local development
```bash
npm install          # Install dependencies
npm run dev          # Start dev server (usually Vite)
```

For API calls to work locally, you need ryuu-proxy configured and `domo login` authenticated.

### Build for production
```bash
npm run build        # Outputs to dist/ (Vite) or build/ (CRA)
```

### Domo CLI Authentication
```bash
domo login           # Authenticate with your Domo instance
```

You'll be prompted for your Domo instance URL and credentials.

### Publishing
```bash
cd dist              # Change to build output directory
domo publish         # Publish to Domo
```

**Important - First publish:**
- On first publish, Domo generates a new `id` for your app
- This ID appears in the published `manifest.json` in your dist folder
- **You must copy this ID back to your source `manifest.json`** (e.g., `public/manifest.json`)
- If you don't, every publish creates a NEW app instead of updating the existing one

```bash
# After first publish, copy the generated ID:
# dist/manifest.json → public/manifest.json (just the "id" field)
```

### Subsequent publishes
Once the ID is in your source manifest:
```bash
npm run build && cd dist && domo publish
```

---

## @domoinc/da CLI - App Scaffolding and Code Generation

The DA CLI (`@domoinc/da`) is a command-line tool for scaffolding Domo custom apps and generating boilerplate code. It's the **recommended way** to create new Domo apps and generate components.

### Purpose

DA CLI provides:
- **Project scaffolding** - Creates new Domo apps with correct structure (Vite + React 18 + TypeScript)
- **Code generation** - Generates components, reducers, and other boilerplate with proper Domo patterns
- **Manifest management** - Manages environment-specific manifest configurations
- **Best practices** - Ensures projects follow Domo conventions from the start

### Installation

```bash
# Install globally
pnpm add -g @domoinc/da

# Or with npm
npm install -g @domoinc/da
```

### Creating a New App

```bash
# Create new Domo app (recommended - Vite + React 18 + TypeScript)
da new my-app-name
cd my-app-name

# With custom template
da new my-app --template @myorg/custom-template
da new my-app --template github.com/user/repo
da new my-app --template ./local-template
```

**Project Structure Created:**
```
my-app/
├── public/
│   ├── manifest.json      # Domo app configuration
│   └── thumbnail.png      # App icon in Domo
├── src/
│   ├── components/        # React components
│   ├── reducers/          # Redux slices (if using)
│   ├── services/          # API service layers
│   ├── types/             # TypeScript definitions
│   └── index.tsx          # App entry point
├── package.json
└── vite.config.ts
```

### Code Generation

```bash
# Generate component with styles, tests, and Storybook
da generate component MyComponent
# Creates:
#   src/components/MyComponent/MyComponent.tsx
#   src/components/MyComponent/MyComponent.module.scss
#   src/components/MyComponent/MyComponent.test.tsx
#   src/components/MyComponent/MyComponent.stories.tsx

# Shorthand
da g component MyComponent

# Generate Redux slice (auto-imports to store)
da generate reducer myFeature
# Creates: src/reducers/myFeature/slice.ts

# Shorthand
da g reducer myFeature
```

### Manifest Management

DA CLI helps manage multiple Domo environments (dev, staging, prod):

```bash
# Create environment-specific manifest overrides
da manifest instance.prod "Production on customer.domo.com"
da manifest instance.dev "Development on dev.domo.com"

# Apply an override before publishing
da apply-manifest instance.prod
yarn upload
```

**Override file structure:**
```json
{
  "instance.prod": {
    "description": "Production environment",
    "manifest": {
      "id": "prod-app-design-id",
      "proxyId": "prod-card-id"
    }
  }
}
```

---

## Converting Generated Apps (Lovable/v0) to Domo

Many developers use AI tools like Lovable, v0, or similar LLM-based generators to create app prototypes. However, these tools typically generate apps with server-side rendering (SSR) that are **incompatible with Domo's client-side-only architecture**.

### The Conversion Challenge

Generated apps often include:
- **Server-side rendering** (Next.js, Remix, SvelteKit, Nuxt)
- **API routes** (`pages/api/` or `app/api/` directories)
- **Server-side data fetching** (`getServerSideProps`, loaders, etc.)
- **Framework-specific routing** (Next.js App Router, Remix routes)

Domo apps must be:
- **Pure client-side React** - No server rendering
- **Static file-based** - Domo serves static files only
- **Domo API integration** - Use `domo.get()`, `Query`, `AppDBClient`, etc. instead of backend endpoints

### Recommended Conversion Pattern

**DA CLI is NOT a conversion tool** - it doesn't automatically convert apps. However, you can use it as a reference structure and starting point.

#### Step 1: Generate Reference Structure

```bash
# Create a fresh Domo app to use as reference
da new my-converted-app
cd my-converted-app

# This gives you the correct structure to compare against
```

#### Step 2: Detect and Remove SSR Code

**Check for SSR indicators:**
- `getServerSideProps`, `getStaticProps` (Next.js)
- `loader`, `action` functions (Remix)
- `+page.server.js`, `+server.js` (SvelteKit)
- `pages/api/` or `app/api/` directories
- Server-side `process.env` usage
- Database connections in components

**Action:** Remove all server-side code. Domo apps run entirely in the browser.

#### Step 3: Replace Data Fetching

**Before (Next.js example):**
```typescript
// ❌ Server-side data fetching
export async function getServerSideProps() {
  const res = await fetch('https://api.example.com/data');
  const data = await res.json();
  return { props: { data } };
}

// ❌ API route
// pages/api/users.ts
export default async function handler(req, res) {
  const users = await db.users.findMany();
  res.json(users);
}
```

**After (Domo):**
```typescript
// ✅ Client-side with Domo APIs
import domo from 'ryuu.js';
import Query from '@domoinc/query';
import { AppDBClient } from '@domoinc/toolkit';

// Fetch from Domo dataset
const data = await domo.get('/data/v1/sales');

// Or use Query API for filtered/aggregated data
const summary = await new Query()
  .select(['region', 'sales'])
  .groupBy('region', { sales: 'sum' })
  .fetch('sales-dataset');

// Or use AppDB for document storage
const tasksClient = new AppDBClient.DocumentsClient('Tasks');
const tasks = await tasksClient.get();
```

#### Step 4: Update Routing

**Before (Next.js):**
```typescript
// ❌ Next.js routing
import Link from 'next/link';
<Link href="/dashboard">Dashboard</Link>
```

**After (Domo):**
```typescript
// ✅ HashRouter for client-side routing
import { HashRouter, Routes, Route } from 'react-router-dom';
import domo from 'ryuu.js';

// Use HashRouter (works without server rewrites)
<HashRouter>
  <Routes>
    <Route path="/" element={<Home />} />
    <Route path="/dashboard" element={<Dashboard />} />
  </Routes>
</HashRouter>

// For Domo navigation, use domo.navigate()
domo.navigate('/page/123456789');
```

#### Step 5: Fix Build Configuration

**Before (Next.js):**
```javascript
// next.config.js
module.exports = {
  // Next.js config
}
```

**After (Domo - Vite):**
```javascript
// vite.config.js
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig({
  base: './',  // CRITICAL: Relative paths for Domo
  plugins: [react()],
});
```

#### Step 6: Port Components

Use DA CLI to generate new components with correct structure, then port logic:

```bash
# Generate component structure
da generate component SalesChart

# Copy component logic from generated app
# Replace data fetching with Domo APIs
# Update imports and dependencies
```

### What DA CLI Helps With

✅ **Reference structure** - Shows correct Domo app organization  
✅ **Component generation** - Creates properly structured components  
✅ **Pattern examples** - Demonstrates Domo conventions  
✅ **Starting fresh** - If conversion is too complex, start new and port logic  

### What DA CLI Doesn't Do

❌ **No automatic conversion** - Doesn't transform SSR to client-side  
❌ **No migration wizard** - No step-by-step conversion tool  
❌ **No code transformation** - Doesn't rewrite framework-specific code  
❌ **No API migration** - Doesn't replace backend calls automatically  

### Complete Conversion Checklist

- [ ] Detect and remove all SSR code
- [ ] Remove API routes (`pages/api/`, `app/api/`)
- [ ] Replace `fetch()` calls to backend with Domo APIs
- [ ] Update routing to `HashRouter`
- [ ] Configure Vite with `base: './'`
- [ ] Replace environment variables (use Domo APIs instead)
- [ ] Update imports (remove Next.js/Remix specific)
- [ ] Test all data fetching works with Domo APIs
- [ ] Verify app builds and runs locally
- [ ] Publish to Domo and test in platform

### Example: Converting a Simple Dashboard

**Original (Lovable/Next.js):**
```typescript
// pages/dashboard.tsx
export async function getServerSideProps() {
  const sales = await fetch('http://api.company.com/sales').then(r => r.json());
  return { props: { sales } };
}

export default function Dashboard({ sales }) {
  return <div>{/* Render sales data */}</div>;
}
```

**Converted (Domo):**
```typescript
// src/components/Dashboard/Dashboard.tsx
import { useEffect, useState } from 'react';
import domo from 'ryuu.js';

export default function Dashboard() {
  const [sales, setSales] = useState([]);

  useEffect(() => {
    // Fetch from Domo dataset instead of backend
    domo.get('/data/v1/sales').then(setSales);
  }, []);

  return <div>{/* Render sales data */}</div>;
}
```

---

## Base Path Configuration (Vite)

Domo serves apps from a subpath, not root. Configure Vite for relative paths:

```javascript
// vite.config.js
export default defineConfig({
  base: './',
  // ... other config
});
```

---

## Routing (React Router)

If using client-side routing, prefer `HashRouter` for App Platform:

```javascript
import { HashRouter } from 'react-router-dom';

// HashRouter works without server rewrites
<HashRouter>
  <App />
</HashRouter>
```

`BrowserRouter` requires server-side rewrite rules which Domo doesn't provide by default.

---

## Common Gotchas & Troubleshooting

### Critical Issues

1. **datasetsMapping requires `fields` array (even if empty)**
   - Omitting `fields` entirely causes: `Cannot read properties of undefined (reading 'map')`
   - Always include `fields: []` even when not aliasing columns
   ```json
   // ✅ Correct
   { "alias": "sales", "dataSetId": "abc-123", "fields": [] }
   
   // ❌ Wrong - missing fields property
   { "alias": "sales", "dataSetId": "abc-123" }
   ```

2. **Query builder aggregation keys must be field names**
   - Aggregation keys in `groupBy()` and `dateGrain()` must match actual dataset field names
   - Using custom aliases causes `[object Object]` errors in results
   ```typescript
   // ✅ Correct - key matches dataset field
   .groupBy('region', { Sales_Amount: 'sum' })
   
   // ❌ Wrong - custom alias as key
   .groupBy('region', { totalSales: 'sum' })
   ```

3. **proxyId required for local dev**
   - Without `proxyId` in manifest.json, local dev can't access AppDB or datasets
   - Must create card first in Domo UI and copy the ID

4. **Collections must be wired in UI**
   - Defining collections in manifest.json isn't enough
   - Must also create/map them in the Domo card UI

5. **SQL endpoint ignores page filters**
   - Use Query endpoint (`/data/v1/`) for dashboard-embedded apps
   - SQL endpoint requires manual filter handling

6. **AI responses are in choices array**
   ```typescript
   // ✅ Correct
   const text = response.choices[0].output;
   
   // ❌ Wrong
   const text = response.output;
   ```

7. **Strip base64 data URL prefix for image-to-text**
   ```typescript
   // ✅ Correct
   const base64 = dataUrl.replace(/^data:image\/\w+;base64,/, '');
   
   // ❌ Wrong - includes prefix
   const base64 = dataUrl;
   ```

8. **Filter dataType is required**
   ```typescript
   // ✅ Correct
   { column: 'amount', operator: 'GREATER_THAN', values: [100], dataType: 'NUMERIC' }
   
   // ❌ Wrong - missing dataType
   { column: 'amount', operator: 'GREATER_THAN', values: [100] }
   ```

### Development Issues

9. **External URLs restricted**
   - Must whitelist domains in Admin > Network Security
   - Fetch to external APIs will fail silently otherwise

10. **Navigation on mobile**
    - Routes auto-prefix with `/m#`
    - Always use `domo.navigate()`, not `window.location` or `<a>` tags

11. **Mobile apps are double iframes**
    - Domo mobile app embeds your app in iframe within its webview
    - Can cause viewport/scroll challenges

12. **AppDB sync is not instant**
    - Default sync to dataset is every 15 minutes
    - Call sync endpoint if you need immediate availability:
    ```javascript
    await domo.post('/domo/datastores/v1/collections/MyCollection/sync');
    ```

### Toolkit Issues

13. **Toolkit uses snake_case for AI methods**
    ```typescript
    // ✅ Correct
    AIClient.generate_text()
    AIClient.text_to_sql()
    
    // ❌ Wrong
    AIClient.generateText()
    AIClient.textToSql()
    ```

14. **Toolkit responses have body wrapper**
    ```typescript
    const response = await IdentityClient.get();
    const user = response.body;  // ✅ Access via .body
    const user = response;       // ❌ This is the wrapper, not the data
    ```

15. **AppDBClient requires instantiation**
    ```typescript
    // ✅ Correct - instantiate with collection name
    const client = new AppDBClient.DocumentsClient('MyCollection');
    
    // ❌ Wrong - not a static method
    AppDBClient.DocumentsClient.get();
    ```

### Debugging Tips

```javascript
// Log all Domo API calls
const originalGet = domo.get;
domo.get = async (...args) => {
  console.log('domo.get called:', args);
  const result = await originalGet.apply(domo, args);
  console.log('domo.get result:', result);
  return result;
};

// Check environment
console.log('Domo env:', domo.env);
console.log('Platform:', domo.env.platform);

// Verify secure identity
const identity = await domo.get('/domo/environment/v1/');
console.log('Verified user:', identity);
```

### Error Handling Pattern

```typescript
const fetchWithErrorHandling = async (url, options) => {
  try {
    return await domo.get(url, options);
  } catch (error) {
    console.error(`API Error: ${url}`, error);
    
    if (error.status === 401) {
      console.error('Unauthorized - user may need to re-authenticate');
    } else if (error.status === 403) {
      console.error('Forbidden - user lacks permission');
    } else if (error.status === 404) {
      console.error('Not found - check dataset alias or endpoint');
    } else if (error.status >= 500) {
      console.error('Server error - try again later');
    }
    
    return null;
  }
};
```

---

## Project-Specific Instructions

Add your project-specific rules below this line:

---

