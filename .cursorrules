# Domo App Platform Custom App Development

You are helping build a Domo App Platform Custom App. This is a client-side web application that runs inside the Domo platform and uses Domo's App Framework APIs.

**Important:** Do NOT confuse the App Platform/Framework APIs with Domo's Public API or Product API - they are different. The App Platform APIs are specifically for custom apps running inside Domo.

---

## ⚠️ Server-Side Rendering Check

**Domo custom apps are client-side only.** There is no server to render pages — Domo serves static files.

When you first look at a project (especially one from Lovable, v0, or similar tools), immediately check for server-side rendering (SSR). If SSR is present, **stop and warn the user** before proceeding.

### Signs of SSR (incompatible with Domo):
- Next.js with `getServerSideProps`, `getStaticProps`, or App Router server components
- Remix with loaders or actions
- SvelteKit with `+page.server.js` or `+server.js` files
- Nuxt.js with server routes
- `pages/api/` or `app/api/` directories (API routes)
- Server-side `process.env` usage for secrets
- Database connections in page components
- `"use server"` directives

### If SSR is detected:
1. **Immediately alert the user** that the project uses server-side rendering
2. Explain that Domo custom apps cannot use SSR — they must be pure client-side apps
3. Recommend refactoring to a client-side only approach (React + Vite is recommended)
4. If they need server-side logic, suggest using Domo Code Engine instead

---

## Domo App Framework APIs

The following APIs are available to custom apps via the `domo.js` library (automatically included when running in Domo):

| API | Purpose |
|-----|---------|
| **Data API** | Query datasets mapped in manifest (`/data/v1/`, `/sql/v1/`) |
| **AppDB** | Document-style collections for app storage (`/domo/datastores/v1/collections/`) |
| **AI Service Layer** | Text generation, image-to-text (`/domo/ai/v1/`) |
| **Code Engine** | Server-side functions for secure operations (`/domo/codeengine/v2/packages/`) |
| **Workflows** | Trigger automation workflows (`/domo/workflow/v1/models/`) |
| **Files** | File storage and retrieval |
| **Filesets** | Grouped file management |
| **Groups** | Domo group information |
| **User** | Current user context |
| **Task Center** | Task management |

See the individual rule files in this repo for detailed usage of each API.

---

## Installing domo.js (ryuu.js)

**React / npm projects:**
```bash
npm install ryuu.js
```
```javascript
import domo from 'ryuu.js';
```

**Vanilla JavaScript (CDN):**
```html
<script src="https://app.unpkg.com/ryuu.js@5.1.2"></script>
```

---

## domo.js Utilities

Beyond the APIs, domo.js provides useful utilities for interacting with the Domo environment:

### Environment Info

Access environment information. **WARNING: Can be spoofed! Do not use for security.**

```javascript
console.log(domo.env.userId);    // User ID (spoofable!)
console.log(domo.env.customer);  // Customer/instance name
console.log(domo.env.pageId);    // Current page ID
console.log(domo.env.locale);    // Locale (e.g., 'en-US')
console.log(domo.env.platform);  // 'desktop' or 'mobile'
```

**For secure user verification:**
```javascript
// ✅ SECURE - Server-verified identity
const verifiedEnv = await domo.get('/domo/environment/v1/');
const { userId, userName, userEmail } = verifiedEnv;

// Or use IdentityClient from toolkit
import { IdentityClient } from '@domoinc/toolkit';
const response = await IdentityClient.get();
const user = response.body; // { id, displayName, emailAddress, role }
```

### Event Listeners
```javascript
// React to dataset updates on the page
domo.onDataUpdated((alias) => {
  console.log(`Dataset ${alias} was updated`);
  // Refresh your data or do nothing to prevent auto-reload
});

// React to page filter changes
domo.onFiltersUpdated((filters) => {
  console.log('Filters changed:', filters);
  // Apply filters to your visualization
});

// React to Domo variable changes
domo.onVariablesUpdated((variables) => {
  console.log('Variables updated:', variables);
});
```

### Navigation
**Important:** Standard anchor tags with `href` do NOT work properly in Domo apps. You must use `domo.navigate()`:

```javascript
// Navigate within Domo
domo.navigate('/page/123456789');

// Open in new tab
domo.navigate('/page/123456789', true);

// External URLs also work
domo.navigate('https://example.com', true);
```

### Fetch Multiple Datasets
```javascript
// Load multiple datasets in parallel
const [sales, customers, products] = await domo.getAll([
  '/data/v1/sales',
  '/data/v1/customers',
  '/data/v1/products'
]);
```

### Update Page Filters Programmatically
```javascript
domo.requestFiltersUpdate(
  [
    {
      column: 'category',
      operator: 'IN',
      values: ['Electronics', 'Clothing'],
      dataType: 'STRING'
    }
  ],
  true, // apply to page
  () => console.log('Filter update acknowledged'),
  (response) => console.log('Filter update completed:', response)
);
```

---

## @domoinc/query - Data Query Builder

**CRITICAL:** Use the Query API (via @domoinc/query) for all dataset queries in Domo apps. This is essential because:

1. **Page Filter Integration** - The Query API automatically respects page-level filters when your app is embedded in a Domo dashboard. This is key for apps that need to respond to dashboard filter changes.

2. **Performance** - The Query API allows you to query only the data you need at the aggregation level required, rather than fetching entire datasets. This is critical for performance, especially with large datasets.

3. **Server-Side Processing** - Aggregations and filtering happen on Domo's servers, reducing data transfer and client-side processing.

The Query library provides a chainable API for building complex data queries. It constructs URLs that work with `domo.get()` and the `/data/v1/` endpoint.

**npm/yarn:**
```bash
yarn add @domoinc/query
```

```typescript
import Query from '@domoinc/query';
```

**CDN (Vanilla JavaScript):**
```html
<script src="https://cdn.jsdelivr.net/npm/@domoinc/query@3.0.0/dist/main.min.js"></script>
```

```javascript
// Query is available globally after CDN script loads
const data = await new Query()
  .select(['region', 'sales'])
  .fetch('sales-dataset');
```

### Basic Usage

```typescript
// Simple query
const data = await new Query()
  .select(['region', 'sales', 'date'])
  .fetch('sales-dataset');

// With filtering
const filtered = await new Query()
  .select(['region', 'product', 'sales'])
  .where('sales').greaterThan(1000)
  .where('region').in(['North', 'South'])
  .fetch('sales-dataset');

// With grouping and aggregation
const summary = await new Query()
  .select(['region', 'sales', 'quantity'])
  .groupBy('region')
  .groupBy({ sales: 'sum', quantity: 'avg' })
  .orderBy('sales', 'descending')
  .limit(10)
  .fetch('sales-dataset');
```

### Select

```typescript
// Select specific columns
new Query().select(['col1', 'col2', 'col3'])

// Select all (omit select)
new Query().fetch('dataset')
```

### Where Filters

All filter methods return the Query for chaining.

```typescript
// Comparison filters
.where('amount').lessThan(100)           // .lt(100)
.where('amount').lessThanOrEqual(100)    // .lte(100)
.where('amount').greaterThan(100)        // .gt(100)
.where('amount').greaterThanOrEqual(100) // .gte(100)
.where('amount').equals(100)
.where('amount').notEquals(100)
.where('amount').between(100, 500)

// String filters
.where('name').contains('test')
.where('name').notContains('test')

// List filters
.where('category').in(['A', 'B', 'C'])
.where('status').notIn(['deleted', 'archived'])

// Multiple conditions (AND)
.where('amount').greaterThan(100)
.where('status').equals('active')
.where('region').in(['North', 'South'])
```

### Group By

```typescript
// Group by single column
.groupBy('region')

// Group by multiple columns
.groupBy('region')
.groupBy('product')

// Group by column with aggregations (second parameter)
.groupBy('region', { 
  sales: 'sum',
  quantity: 'avg',
  price: 'max',
  orders: 'count',
  skus: 'unique'
})

// Multiple groupBy calls
.groupBy('region')
.groupBy('product', { sales: 'sum', orders: 'count' })
```

**Aggregation Functions:**
- `'count'` - Count rows
- `'sum'` - Sum values
- `'avg'` - Average values
- `'min'` - Minimum value
- `'max'` - Maximum value
- `'unique'` - Count distinct values

#### CRITICAL - Aggregation Key Syntax

**Aggregation keys MUST be the actual field names from your dataset, NOT custom aliases.**

The key in the aggregation object determines the output property name. If you use an alias that doesn't match a field, you'll get `[object Object]` errors.

```typescript
// ✅ CORRECT - Keys match actual field names
// If your dataset has fields: 'Sales_Amount', 'Order_Qty'
.groupBy('region', { 
  Sales_Amount: 'sum',   // Key matches dataset field
  Order_Qty: 'count'     // Key matches dataset field
})

// Results: [{ region: 'North', Sales_Amount: 50000, Order_Qty: 150 }]

// ❌ WRONG - Custom aliases as keys cause [object Object] errors
.groupBy('region', { 
  totalSales: 'sum',     // 'totalSales' is not a field name!
  orderCount: 'count'    // 'orderCount' is not a field name!
})

// ✅ If you need custom names, rename AFTER fetching:
const data = await new Query()
  .groupBy('region', { Sales_Amount: 'sum' })
  .fetch('sales');

const renamed = data.map(row => ({
  region: row.region,
  totalSales: row.Sales_Amount  // Rename here
}));
```

### Order By

```typescript
.orderBy('sales', 'descending')  // or 'desc'
.orderBy('date', 'ascending')    // or 'asc'

// Multiple sort columns
.orderBy('region', 'ascending')
.orderBy('sales', 'descending')
```

### Limit and Offset

```typescript
.limit(100)    // Max rows
.offset(50)    // Skip rows (for pagination)

// Pagination example
const page = 2;
const pageSize = 25;
new Query()
  .limit(pageSize)
  .offset((page - 1) * pageSize)
  .fetch('dataset');
```

### Date Operations

#### dateGrain - Group by Date Period

```typescript
// Group by month
.dateGrain('order_date', 'month')

// Group by month with aggregations
// NOTE: Aggregation keys must be actual field names!
.dateGrain('order_date', 'month', { Revenue: 'sum', Order_Count: 'count' })

// Available grains: 'day', 'week', 'month', 'quarter', 'year'
.dateGrain('date', 'day')
.dateGrain('date', 'week')
.dateGrain('date', 'month')
.dateGrain('date', 'quarter')
.dateGrain('date', 'year')
```

**CRITICAL:** The third parameter (aggregations) follows the same rules as `groupBy` - keys must match actual dataset field names:

```typescript
// ✅ CORRECT - field names as keys
.dateGrain('order_date', 'month', { Sales_Amount: 'sum' })

// ❌ WRONG - custom aliases cause errors
.dateGrain('order_date', 'month', { totalSales: 'sum' })
```

#### periodToDate - YTD, MTD, QTD, etc.

```typescript
// Year to date
.periodToDate('date', 'year')

// Month to date
.periodToDate('date', 'month')

// Quarter to date
.periodToDate('date', 'quarter')

// Full example
const ytdSales = await new Query()
  .select(['date', 'sales'])
  .periodToDate('date', 'year')
  .groupBy({ sales: 'sum' })
  .fetch('sales');
```

#### previousPeriod - Last Period Comparison

```typescript
// Last year
.previousPeriod('date', 'year')

// Last month
.previousPeriod('date', 'month')

// Last quarter
.previousPeriod('date', 'quarter')
```

#### rollingPeriod - Rolling Windows

```typescript
// Last 30 days
.rollingPeriod('date', 'days', 30)

// Last 12 weeks
.rollingPeriod('date', 'weeks', 12)

// Last 6 months
.rollingPeriod('date', 'months', 6)

// Last 4 quarters
.rollingPeriod('date', 'quarters', 4)

// Last 3 years
.rollingPeriod('date', 'years', 3)
```

### Additional Options

```typescript
// Use fiscal calendar
.useFiscalCalendar(true)

// Enable beast modes (calculated fields)
.useBeastModes()

// Aggregate without grouping
.aggregate({ total: 'sum', average: 'avg' })
```

### Complete Examples

```typescript
// Sales dashboard query
const salesByRegion = await new Query()
  .select(['region', 'product_category', 'sales', 'quantity', 'date'])
  .where('sales').greaterThan(0)
  .where('date').greaterThanOrEqual('2024-01-01')
  .dateGrain('date', 'month')
  .groupBy('region')
  .groupBy('product_category')
  .groupBy({ sales: 'sum', quantity: 'sum', orders: 'count' })
  .orderBy('sales', 'descending')
  .limit(100)
  .fetch('sales-dataset');

// YoY comparison
const thisYear = await new Query()
  .select(['month', 'revenue'])
  .periodToDate('date', 'year')
  .dateGrain('date', 'month', { revenue: 'sum' })
  .fetch('revenue');

const lastYear = await new Query()
  .select(['month', 'revenue'])
  .previousPeriod('date', 'year')
  .dateGrain('date', 'month', { revenue: 'sum' })
  .fetch('revenue');

// Trend analysis - last 90 days
const trend = await new Query()
  .select(['date', 'sales', 'orders'])
  .rollingPeriod('date', 'days', 90)
  .dateGrain('date', 'day', { sales: 'sum', orders: 'count' })
  .orderBy('date', 'ascending')
  .fetch('sales');
```

---

## manifest.json

The `manifest.json` file is critical - it declares all external resources your app needs. Domo uses this to:
1. Know which datasets, collections, workflows, and code engine functions to connect
2. Map aliases (used in your code) to actual Domo resource IDs (configured at publish time)

### Basic structure
```json
{
  "name": "My App Name",
  "version": "1.0.0",
  "id": "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx",
  "fullpage": true,
  "size": {
    "width": 4,
    "height": 3
  },
  "datasetsMapping": [],
  "collections": [],
  "workflowMapping": [],
  "packageMapping": []
}
```

### Key properties
- `name` / `version` - App metadata
- `id` - **Generated on first publish** (see deployment section)
- `fullpage` - Set `true` for full-page apps
- `size` - Card dimensions (width/height in grid units)
- `datasetsMapping` - Datasets the app can query
- `collections` - AppDB collections for storage
- `workflowMapping` - Workflows the app can trigger
- `packageMapping` - Code Engine functions the app can call

### Required files
- `manifest.json` - App configuration (required)
- `thumbnail.png` - App thumbnail image (required, must be alongside manifest.json)

---

## Build & Deploy Workflow

### Prerequisites
- Node.js installed
- Domo CLI installed (`npm install -g @domoinc/ryuu`)

### Local development
```bash
npm install          # Install dependencies
npm run dev          # Start dev server (usually Vite)
```

For API calls to work locally, you need ryuu-proxy configured and `domo login` authenticated.

### Build for production
```bash
npm run build        # Outputs to dist/ (Vite) or build/ (CRA)
```

### Domo CLI Authentication
```bash
domo login           # Authenticate with your Domo instance
```

You'll be prompted for your Domo instance URL and credentials.

### Publishing
```bash
cd dist              # Change to build output directory
domo publish         # Publish to Domo
```

**Important - First publish:**
- On first publish, Domo generates a new `id` for your app
- This ID appears in the published `manifest.json` in your dist folder
- **You must copy this ID back to your source `manifest.json`** (e.g., `public/manifest.json`)
- If you don't, every publish creates a NEW app instead of updating the existing one

```bash
# After first publish, copy the generated ID:
# dist/manifest.json → public/manifest.json (just the "id" field)
```

### Subsequent publishes
Once the ID is in your source manifest:
```bash
npm run build && cd dist && domo publish
```

---

## Base Path Configuration (Vite)

Domo serves apps from a subpath, not root. Configure Vite for relative paths:

```javascript
// vite.config.js
export default defineConfig({
  base: './',
  // ... other config
});
```

---

## Routing (React Router)

If using client-side routing, prefer `HashRouter` for App Platform:

```javascript
import { HashRouter } from 'react-router-dom';

// HashRouter works without server rewrites
<HashRouter>
  <App />
</HashRouter>
```

`BrowserRouter` requires server-side rewrite rules which Domo doesn't provide by default.

---

## Common Gotchas & Troubleshooting

### Critical Issues

1. **datasetsMapping requires `fields` array (even if empty)**
   - Omitting `fields` entirely causes: `Cannot read properties of undefined (reading 'map')`
   - Always include `fields: []` even when not aliasing columns
   ```json
   // ✅ Correct
   { "alias": "sales", "dataSetId": "abc-123", "fields": [] }
   
   // ❌ Wrong - missing fields property
   { "alias": "sales", "dataSetId": "abc-123" }
   ```

2. **Query builder aggregation keys must be field names**
   - Aggregation keys in `groupBy()` and `dateGrain()` must match actual dataset field names
   - Using custom aliases causes `[object Object]` errors in results
   ```typescript
   // ✅ Correct - key matches dataset field
   .groupBy('region', { Sales_Amount: 'sum' })
   
   // ❌ Wrong - custom alias as key
   .groupBy('region', { totalSales: 'sum' })
   ```

3. **proxyId required for local dev**
   - Without `proxyId` in manifest.json, local dev can't access AppDB or datasets
   - Must create card first in Domo UI and copy the ID

4. **Collections must be wired in UI**
   - Defining collections in manifest.json isn't enough
   - Must also create/map them in the Domo card UI

5. **SQL endpoint ignores page filters**
   - Use Query endpoint (`/data/v1/`) for dashboard-embedded apps
   - SQL endpoint requires manual filter handling

6. **AI responses are in choices array**
   ```typescript
   // ✅ Correct
   const text = response.choices[0].output;
   
   // ❌ Wrong
   const text = response.output;
   ```

7. **Strip base64 data URL prefix for image-to-text**
   ```typescript
   // ✅ Correct
   const base64 = dataUrl.replace(/^data:image\/\w+;base64,/, '');
   
   // ❌ Wrong - includes prefix
   const base64 = dataUrl;
   ```

8. **Filter dataType is required**
   ```typescript
   // ✅ Correct
   { column: 'amount', operator: 'GREATER_THAN', values: [100], dataType: 'NUMERIC' }
   
   // ❌ Wrong - missing dataType
   { column: 'amount', operator: 'GREATER_THAN', values: [100] }
   ```

### Development Issues

9. **External URLs restricted**
   - Must whitelist domains in Admin > Network Security
   - Fetch to external APIs will fail silently otherwise

10. **Navigation on mobile**
    - Routes auto-prefix with `/m#`
    - Always use `domo.navigate()`, not `window.location` or `<a>` tags

11. **Mobile apps are double iframes**
    - Domo mobile app embeds your app in iframe within its webview
    - Can cause viewport/scroll challenges

12. **AppDB sync is not instant**
    - Default sync to dataset is every 15 minutes
    - Call sync endpoint if you need immediate availability:
    ```javascript
    await domo.post('/domo/datastores/v1/collections/MyCollection/sync');
    ```

### Toolkit Issues

13. **Toolkit uses snake_case for AI methods**
    ```typescript
    // ✅ Correct
    AIClient.generate_text()
    AIClient.text_to_sql()
    
    // ❌ Wrong
    AIClient.generateText()
    AIClient.textToSql()
    ```

14. **Toolkit responses have body wrapper**
    ```typescript
    const response = await IdentityClient.get();
    const user = response.body;  // ✅ Access via .body
    const user = response;       // ❌ This is the wrapper, not the data
    ```

15. **AppDBClient requires instantiation**
    ```typescript
    // ✅ Correct - instantiate with collection name
    const client = new AppDBClient.DocumentsClient('MyCollection');
    
    // ❌ Wrong - not a static method
    AppDBClient.DocumentsClient.get();
    ```

### Debugging Tips

```javascript
// Log all Domo API calls
const originalGet = domo.get;
domo.get = async (...args) => {
  console.log('domo.get called:', args);
  const result = await originalGet.apply(domo, args);
  console.log('domo.get result:', result);
  return result;
};

// Check environment
console.log('Domo env:', domo.env);
console.log('Platform:', domo.env.platform);

// Verify secure identity
const identity = await domo.get('/domo/environment/v1/');
console.log('Verified user:', identity);
```

### Error Handling Pattern

```typescript
const fetchWithErrorHandling = async (url, options) => {
  try {
    return await domo.get(url, options);
  } catch (error) {
    console.error(`API Error: ${url}`, error);
    
    if (error.status === 401) {
      console.error('Unauthorized - user may need to re-authenticate');
    } else if (error.status === 403) {
      console.error('Forbidden - user lacks permission');
    } else if (error.status === 404) {
      console.error('Not found - check dataset alias or endpoint');
    } else if (error.status >= 500) {
      console.error('Server error - try again later');
    }
    
    return null;
  }
};
```

---

## Project-Specific Instructions

Add your project-specific rules below this line:

---

